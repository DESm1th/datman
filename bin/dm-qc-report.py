#!/usr/bin/env python
"""
Generates quality control reports on defined MRI data types. If no subject is
given, all subjects are submitted individually to the queue.

usage:
    dm-qc-report.py [options] <config>

Options:
    --subject SCANID        Scan ID to QC for. E.g. DTI_CMH_H001_01_01
    --walltime              Walltime for batch mode jobs [default: 1:00:00]
    --rewrite               Rewrite the html of an existing qc page
    --debug                 Be extra chatty
    --dry-run               Don't actually do any work

Details:
    This program QCs the data contained in <NiftiDir> and <DicomDir>, and
    outputs a myriad of metrics as well as a report in <QCDir>. All work is done
    on a per-subject basis.

    **data directories**

    The folder structure expected is that generated by xnat-export.py:

        <NiftiDir>/
           subject1/
               file1.nii.gz
               file2.nii.gz
           subject2/
               file1.nii.gz
               file2.nii.gz

        <DicomDir>/
           subject1/
               file1.dcm
               file2.dcm
           subject2/
               file1.dcm
               file2.dcm

     There should be a .dcm file for each .nii.gz. One subfolder for each
     subject will be created under the <QCDir> folder.

     **gold standards**

     To check for changes to the MRI machine's settings over time, this compares
     the headers found in <DicomDir> with the appropriate dicom file found in
     <StandardsDir>/<Tag>/filename.dcm.

     **configuration file**

     The locations of the dicom folder, nifti folder, qc folder, gold standards
     folder, and expected set of scans are read from the supplied configuration
     file with the following structure:

     paths:
       dcm: '/archive/data/SPINS/data/dcm'
       nii: '/archive/data/SPINS/data/nii'
       qc:  '/archive/data/SPINS/qc'
       std: '/archive/data/SPINS/metadata/standards'

     Sites:
       site1:
         XNAT_Archive: '/path/to/arc001'
         ExportInfo:
           - T1:  {Pattern: {'regex1', 'regex2'}, Count: n_expected}
           - DTI: {Pattern: {'regex1', 'regex2'}, Count: n_expected}
       site2 :
         XNAT_Archive: '/path/to/arc001'
         ExportInfo:
           - T1:  {Pattern: {'regex1', 'regex2'}, Count: n_expected}
           - DTI: {Pattern: {'regex1', 'regex2'}, Count: n_expected}
Requires:
    FSL
    QCMON
"""

import os, sys
import glob
import time
import logging
import datman as dm
import subprocess as proc
from datman.docopt import docopt
#import re
import tempfile
import yaml
import pandas as pd

logging.basicConfig(level=logging.WARN, format="[%(name)s] %(levelname)s: %(message)s")
logger = logging.getLogger(os.path.basename(__file__))

DEBUG = False
VERBOSE = False
DRYRUN = False
FIGDPI = 144
REWRITE = False

class Document:
    pass

# HELPERS
def makedirs(path):
    logger.debug("makedirs: {}".format(path))
    if not DRYRUN: os.makedirs(path)

def run(cmd):
    logger.debug("exec: {}".format(cmd))
    if not DRYRUN:
        p = proc.Popen(cmd, shell=True, stdout=proc.PIPE, stderr=proc.PIPE)
        out, err = p.communicate()
        if p.returncode != 0:
            logger.error("Error {} while executing: {}".format(p.returncode, cmd))
            out and logger.error("stdout: \n>\t{}".format(out.replace('\n','\n>\t')))
            err and logger.error("stderr: \n>\t{}".format(err.replace('\n','\n>\t')))
        else:
            logger.debug("rtnval: {}".format(p.returncode))
            out and logger.debug("stdout: \n>\t{}".format(out.replace('\n','\n>\t')))
            err and logger.debug("stderr: \n>\t{}".format(err.replace('\n','\n>\t')))

def slicer(fpath, pic, slicergap, picwidth):
    """
    Uses FSL's slicer function to generate a montage png from a nifti file
        fpath       -- submitted image file name
        slicergap   -- int of "gap" between slices in Montage
        picwidth    -- width (in pixels) of output image
        pic         -- fullpath to for output image
    """
    run("slicer {} -S {} {} {}".format(fpath,slicergap,picwidth,pic))

def find_expected_files(config, scanpath, subject):
    """
    Reads in the export info from the config file and compares it to the
    contents of the nii folder. Data written to a pandas dataframe.
    """
    allpaths = []
    for filetype in ('*.nii.gz', '*.nii'):
        allpaths.extend(glob.glob(scanpath + '/*' + filetype))

    allfiles = []
    for f in allpaths:
        allfiles.append(os.path.basename(f))

    cols = ['tag', 'File', 'bookmark', 'Note']
    exportinfo = pd.DataFrame(columns=cols)
    idx = 0

    for sitedict in config['Sites']:
        site = sitedict.keys()[0]

        if site in subject:
            for row in sitedict[site]['ExportInfo']:
                tag = row.keys()[0]
                expected_count = row[tag]['Count']
                tagstring = "_{}_".format(tag)
                files = [k for k in allfiles if tagstring in k]
                files.sort()
                filenum = 1

                for f in files:
                    bookmark = tag + str(filenum)
                    notes = 'Repeated Scan' if filenum > expected_count else ''
                    exportinfo.loc[idx] = [tag, f, bookmark, notes]
                    idx += 1
                    filenum += 1

                if filenum < (expected_count + 1):
                    notes = 'missing({})'.format(expected_count - filenum + 1)
                    exportinfo.loc[idx] = [tag, '', '', notes]
                    idx += 1

    # TODEPRICATE: hacks for 'other' scantypes
    exportinfoFiles = exportinfo.File.tolist()
    PDT2scans = [k for k in exportinfoFiles if '_PDT2_' in k]
    if len(PDT2scans) > 0:
        for PDT2scan in PDT2scans:
            exportinfoFiles.append(PDT2scan.replace('_PDT2_','_T2_'))
            exportinfoFiles.append(PDT2scan.replace('_PDT2_','_PD_'))
    otherscans = list(set(allfiles) - set(exportinfoFiles))
    for scan in otherscans:
        exportinfo.loc[idx] = ['unknown', scan, '', 'extra scan']
        idx += 1

    return(exportinfo)

def write_table(report, exportinfo):
    report.write('<table>'
                 '<tr><th>Tag</th>'
                 '<th>File</th>'
                 '<th>Notes</th></tr>')

    for row in range(0,len(exportinfo)):
        report.write('<tr><td>{}</td>'.format(exportinfo.loc[row,'tag'])) ## table new row
        report.write('<td><a href="#{}">{}</a></td>'.format(exportinfo.loc[row,'bookmark'],exportinfo.loc[row,'File']))
        report.write('<td><font color="#FF0000">{}</font></td></tr>'.format(exportinfo.loc[row,'Note'])) ## table new row
    report.write('</table>\n')

def nifti_basename(fpath):
    """
    return basename with out .nii.gz extension
    """
    basefpath = os.path.basename(fpath)
    stem = basefpath.replace('.nii.gz','')

    return(stem)

def add_image(qchtml, image):
    """
    Adds an image to the report.
    """
    relpath = os.path.relpath(image, os.path.dirname(qchtml.name))
    qchtml.write('<a href="'+ relpath + '" >')
    qchtml.write('<img src="' + relpath + '" > ')
    qchtml.write('</a><br>\n')

    return qchtml

def add_header_qc(fpath, qchtml, logdata):
    """
    Adds header diff infortmation to the report.
    """
    filestem = os.path.basename(fpath).replace(dm.utils.get_extension(fpath),'')
    lines = [re.sub('^.*?: *','',line) for line in logdata if filestem in line]
    if not lines:
        return

    qchtml.write('<h3> {} header differences </h3>\n<table>'.format(filestem))
    for l in lines:
        qchtml.write('<tr><td>{}</td></tr>'.format(l))
    qchtml.write('</table>\n')

# PIPELINES
def ignore(fpath, qcpath, qchtml):
    pass

def phantom_fmri_qc(fileName, outputDir):
    """
    Runs the fbirn fMRI pipeline on input phantom data if the outputs don't
    already exist.
    """
    basename = nifti_basename(fileName)
    outputFile = os.path.join(outputDir, '{}_stats.csv'.format(basename))
    outputPrefix = os.path.join(outputDir, basename)
    if not os.path.isfile(outputFile):
        run('qc-fbirn-fmri {} {}'.format(fileName, outputPrefix))

def phantom_dti_qc(fileName, outputDir):
    """
    Runs the fbirn DTI pipeline on input phantom data if the outputs don't
    already exist.
    """
    dirname = os.path.dirname(fileName)
    basename = nifti_basename(fileName)

    outputFile = os.path.join(outputDir, '{}_stats.csv'.format(basename))
    outputPrefix = os.path.join(outputDir, basename)

    if not os.path.isfile(outputFile):
        bvec = os.path.join(dirname, basename + '.bvec')
        bval = os.path.join(dirname, basename + '.bval')
        run('qc-fbirn-dti {} {} {} {} n'.format(fileName, bvec, bval, outputPrefix))

def phantom_anat_qc(fileName, outputDir):
    """
    Runs the ADNI pipeline on input phantom data if the outputs don't already
    exist.
    """
    basename = nifti_basename(fileName)
    outputFile = os.path.join(outputDir, '{}_adni-contrasts.csv'.format(basename))
    if not os.path.isfile(outputFile):
        run('qc-adni {} {}'.format(fileName, outputFile))

def fmri_qc(fileName, qcDir, report):
    dirname = os.path.dirname(fileName)
    basename = nifti_basename(fileName)

    # check scan length
    outputFile = os.path.join(qcDir, basename + '_scanlengths.csv')
    if not os.path.isfile(output):
        dm.utils.run('qc-scanlength {} {}'.format(fileName, outputFile))

    # check fmri signal
    outputPrefix = os.path.join(qcDir, basename)
    outputFile = outputPrefix + '_stats.csv'
    if not os.path.isfile(outputFile):
        dm.utils.run('qc-fmri {} {}'.format(fileName, outputPrefix))

    imageRaw = os.path.join(qcDir, basename + '_raw.png')
    imageSfnr = os.path.join(qcDir, basename + '_sfnr.png')
    imageCorr = os.path.join(qcDir, basename + '_corr.png')

    if not os.path.isfile(imageRaw):
        slicer(fileName, imageRaw, 2, 1600)
        add_image(report, imageRaw)

    if not os.path.isfile(imageSfnr):
        slicer(os.path.join(qcDir, basename + '_sfnr.nii.gz'), imageSfnr, 2, 1600)
        add_image(report, imageSfnr)

    if not os.path.isfile(imageCorr):
        slicer(os.path.join(qcDir, basename + '_corr.nii.gz'), imageCorr, 2, 1600)
        add_image(report, imageCorr)



def anat_qc(fileName, qcDir, report):

    image = os.path.join(qcDir, nifti_basename(fileName) + '.png')
    if not os.path.isfile(image):
        slicer(fileName, image, 5, 1600)
        add_image(report, image)

def dti_qc(fileName, qcDir, report):
    dirname = os.path.dirname(fileName)
    basename = nifti_basename(fileName)

    bvec = os.path.join(dirname, basename + '.bvec')
    bval = os.path.join(dirname, basename + '.bval')

    outputPrefix = os.path.join(qcDir, basename)
    outputFile = outputPrefix + '_stats.csv'
    if not os.path.isfile(outputFile):
        dm.utils.run('qc-dti {} {} {} {}'.format(fileName, bvec, bval, outputPrefix))

    outputFile = os.path.join(qcDir, basename + '_spikecount.csv')
    if not os.path.isfile(outputFile):
        dm.utils.run('qc-spikecount {} {} {}'.format(fileName, os.path.join(qcDir, basename + '_spikecount.csv'), bval))

    image = os.path.join(qcDir, basename + '_b0.png')
    if not os.path.isfile(image):
        slicer(fileName, image, 2, 1600)
        add_image(report, image)

def run_header_qc(dicomDir, standardDir, logfile):
    """
    For each .dcm file found in 'dicoms', find the matching site/tag file in
    'standards', and run qc-headers (from qcmon) on these files. Any
    are written to logfile.
    """

    dicoms = glob.glob(os.path.join(dicomDir, '*'))
    standards = glob.glob(os.path.join(standardDir, '*'))

    site = dm.scanid.parse_filename(dicoms[0])[0].site

    # build standard dict
    standardDict = {}
    for s in standards:
        if dm.scanid.parse_filename(s)[0].site == site:
            standardDict[dm.scanid.parse_filename(s)[1]] = s

    for d in dicoms:
        tag = dm.scanid.parse_filename(d)[1]
        try:
            s = standardDict[tag]
        except:
            print('WARNING: No standard with tag {} found in {}'.format(tag, standardDir))
            continue

        # run header check for dicom
        run('qc-headers {} {} {}'.format(d, s, logfile))

# MAIN FUNCTIONS
def qc_phantom(scanpath, subject, config):
    """
    QC all the images in a folder (scanpath) for a non-human participant. Data
    written to outputdir. No report is generated for phantom data. config is
    loaded from the project_settings.yml file.
    """
    HANDLERS = {
        "T1"            : phantom_anat_qc,
        "RST"           : phantom_fmri_qc,
        "DTI60-1000"    : phantom_dti_qc,
    }

    qcDir = dm.utils.define_folder(config['paths']['qc'])
    qcDir = dm.utils.define_folder(os.path.join(qcDir, subject))

    niftis = glob.glob(os.path.join(scanpath, '*.nii.gz'))

    for nifti in niftis:
        ident, tag, series, description = dm.scanid.parse_filename(nifti)
        if tag not in HANDLERS:
            logger.info("MSG: No QC tag {} for scan {}. Skipping.".format(tag, nifti))
            continue
        HANDLERS[tag](nifti, qcDir)

def qc_subject(scanpath, subject, config):
    """
    QC all the images in a folder (scanpath) for a human participant. Report
    written to  outputdir. config is loaded from the project_settings.yml file.
    """
    HANDLERS = {   # map from tag to QC function
        "T1"            : anat_qc,
        "T2"            : anat_qc,
        "PD"            : anat_qc,
        "PDT2"          : anat_qc,
        "FLAIR"         : anat_qc,
        "FMAP"          : ignore,
        "FMAP-6.5"      : ignore,
        "FMAP-8.5"      : ignore,
        "RST"           : fmri_qc,
        "EPI"           : fmri_qc,
        "SPRL"          : fmri_qc,
        "OBS"           : fmri_qc,
        "IMI"           : fmri_qc,
        "NBK"           : fmri_qc,
        "EMP"           : fmri_qc,
        "VN-SPRL"       : fmri_qc,
        "SID"           : fmri_qc,
        "MID"           : fmri_qc,
        "DTI"           : dti_qc,
        "DTI21"         : dti_qc,
        "DTI22"         : dti_qc,
        "DTI23"         : dti_qc,
        "DTI60-29-1000" : dti_qc,
        "DTI60-20-1000" : dti_qc,
        "DTI60-1000"    : dti_qc,
        "DTI60-b1000"   : dti_qc,
        "DTI33-1000"    : dti_qc,
        "DTI33-b1000"   : dti_qc,
        "DTI33-3000"    : dti_qc,
        "DTI33-b3000"   : dti_qc,
        "DTI33-4500"    : dti_qc,
        "DTI33-b4500"   : dti_qc,
    }

    qcDir = dm.utils.define_folder(config['paths']['qc'])
    qcDir = dm.utils.define_folder(os.path.join(qcDir, subject))
    report = os.path.join(qcDir, 'qc_{}.html'.format(subject))

    if os.path.isfile(report) and not REWRITE:
        logger.debug("MSG: {} exists, skipping.".format(report))
        return

    if os.path.isfile(report) and REWRITE:
        os.remove(report)

    report = open(report, 'wb')
    report.write('<HTML><TITLE>{} qc</TITLE>\n'.format(subject))
    report.write('<head>\n<style>\n'
                'body { font-family: futura,sans-serif;'
                '        text-align: center;}\n'
                'img {width:90%; \n'
                '   display: block\n;'
                '   margin-left: auto;\n'
                '   margin-right: auto }\n'
                'table { margin: 25px auto; \n'
                '        border-collapse: collapse;\n'
                '        text-align: left;\n'
                '        width: 90%; \n'
                '        border: 1px solid grey;\n'
                '        border-bottom: 2px solid black;} \n'
                'th {background: black;\n'
                '    color: white;\n'
                '    text-transform: uppercase;\n'
                '    padding: 10px;}\n'
                'td {border-top: thin solid;\n'
                '    border-bottom: thin solid;\n'
                '    padding: 10px;}\n'
                '</style></head>\n')

    report.write('<h1> QC report for {} <h1/>'.format(subject))

    exportinfo = find_expected_files(config, scanpath, subject)
    write_table(report, exportinfo)

    # technotes
    if 'CMH' in subject:
        technotes = glob.glob('{}/../../RESOURCES/{}*/*/*/*.pdf'.format(scanpath, subject))

        if len(technotes) > 0:
            technotes = os.path.relpath(os.path.abspath(technotes[0]), os.path.dirname(report.name))
            report.write('<a href="{}">\nClick Here to open Tech Notes</a><br>\n'.format(technotes))
        else:
            report.write('<p>Tech Notes not found</p>\n')

    # header diff
    dcmSubj = os.path.join(config['paths']['dcm'], subject)
    headerDiff = os.path.join(qcDir, 'header-diff.log'.format(subject))
    if not os.path.isfile(headerDiff):
        run_header_qc(dcmSubj, config['paths']['std'], headerDiff)

    # run QC pipieline on each scan
    for idx in range(0,len(exportinfo)):
        name = exportinfo.loc[idx,'File']
        if name!='' :
            fname = os.path.join(scanpath, name)
            logger.info("QC scan {}".format(fname))
            ident, tag, series, description = dm.scanid.parse_filename(fname)
            report.write('<h2 id="{}">{}</h2>\n'.format(exportinfo.loc[idx,'bookmark'], name))

            if tag not in HANDLERS:
                logger.info("MSG: No QC tag {} for scan {}. Skipping.".format(tag, fname))
                continue

            add_header_qc(fname, report, headerDiff)

            HANDLERS[tag](fname, qcDir, report)
            report.write('<br>')

    report.close()

def main():

    global DEBUG
    global DRYRUN
    global REWRITE

    arguments = docopt(__doc__)

    config_file = arguments['<config>']
    scanid     = arguments['--subject']
    walltime   = arguments['--walltime']
    REWRITE    = arguments['--rewrite']
    DEBUG      = arguments['--debug']
    DRYRUN     = arguments['--dry-run']

    with open(config_file, 'r') as stream:
        config = yaml.load(stream)

    for k in ['dcm', 'nii', 'qc', 'std']:
        if k not in config['paths']:
            sys.exit("ERROR: paths:{} not defined in {}".format(k, configfile))

    if DEBUG:
        logging.getLogger().setLevel(logging.DEBUG)

    nii_dir = config['paths']['nii']

    if scanid:
        path = os.path.join(nii_dir, scanid)

        if 'PHA' in subject:
            logger.info("MSG: qc phantom {}".format(path))
            qc_phantom(path, scanid, config)
        else:
            logger.info("MSG: qc {}".format(path))
            qc_subject(path, scanid, config)

    # run in batch mode
    else:
        commands = []
        for path in glob.glob('{}/*'.format(nii_dir)):
            subject = os.path.basename(path)

            if REWRITE:
                commands.append(" ".join([__file__, config_file, '--subject {}'.format(subject)], REWRITE))
            else:
                commands.append(" ".join([__file__, config_file, '--subject {}'.format(subject)]))

        if commands:
            jobname = "dm_qc_report_{}".format(time.strftime("%Y%m%d-%H%M%S"))
            fd, path = tempfile.mkstemp()
            os.write(fd, '\n'.join(commands))
            os.close(fd)

            rtn, out, err = dm.utils.run('qbatch -i -N {name} --walltime {wt} {cmds}'.format(
                name = jobname,
                wt = walltime,
                cmds = path), dryrun = DRYRUN)

            if rtn != 0:
                logger.error("Job submission failed.")
                logger.error("stdout: {}\nstderr: {}".format(out,err))
                sys.exit(1)

if __name__ == "__main__":
    main()

